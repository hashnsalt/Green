<!DOCTYPE html>
<html lang="kr">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>React11</title>
</head>
<body>

  <div id="root"></div>

  <!-- React -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- dom을 다루는 라이브러리  -->


  <!-- Load Babel -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>



  <!-- Your custom script here -->
  <script type="text/babel">
    
    const rootElement = document.getElementById('root');

      class MyEvent extends React.Component {
        //메세지값이 바뀌기 때문에 state 값 정의
        state = {
          message: ''
        }

        render() {
          return (
            <div>
              <h1>Event Class</h1>
              <input 
              type="text"
              name="message"
              placeholder='메세지 입력'
              value = {this.state.message}
              onChange = {
                (e) => {//e: 외부에서 들어오는 값
                  this.setState({ //외부에서 들어온 값을 받겠다.
                    message: e.target.value //e로 들어온는 값을 value로 받아서 message에 넣어줌.
                    //메세지를 한번 받으면(이벤트가 한번 끝나면) 값이 초기화 되어버림. 그러므로 이벤트의 초기화를 막기 위해 target이라는 키워드를 사용. //undefine오류를 방지하기 위해 target을 사용.
                    //onChange 이벤트가 발생하면 e.target.value를 통해 이벤트 객체에 담겨 있는 input값을 읽어 올 수 있음.
                  })
                }
              } 
              />
              <button
                  onClick = {() => {
                  alert(this.state.message)
                  this.setState({message: ''}) //새롭게 값을 넣기 위해 초기화 시켜줌.
                }}
              >확인</button>
            </div>
          )

        }

      }//class



    ReactDOM.render(<MyEvent />, rootElement);

  </script>

</body>
</html>